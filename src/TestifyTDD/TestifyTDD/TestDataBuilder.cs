using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Reflection;
using TestifyTDD.Helpers;

namespace TestifyTDD
{
    public class TestDataBuilder<TDOMAIN, TTHIS> : ITestDataBuilder<TDOMAIN, TTHIS>
        where TTHIS : TestDataBuilder<TDOMAIN, TTHIS>, new()
    {
        private Dictionary<PropertyInfo, object> _propertyValues = 
            new Dictionary<PropertyInfo, object>();

        protected PropertyHelper<TDOMAIN> _helper = new PropertyHelper<TDOMAIN>();
        
        public TestDataBuilder()
        {
            PostBuildEvent += OnPostBuild;
        }

        public virtual TDOMAIN Build()
        {
            const bool allowNonPublicConstructors = true;
            
            var domainObj = 
                (TDOMAIN)Activator.CreateInstance(
                             typeof(TDOMAIN), allowNonPublicConstructors);
            
            foreach (var propertyInfo in _propertyValues.Keys)
            {
                var value = _propertyValues[propertyInfo];
                var setter = _helper.GetValueSetter(propertyInfo);

                if (IsITestDataBuilder(value))
                    setter(domainObj, GetValueFromBuilder(value));
                else
                    setter(domainObj, value);
            }

            FireOnPostBuild(domainObj);

            //System.Diagnostics.Debug.WriteLine("Built: " + typeof(TDOMAIN).Name + " hash = " + domainObj.GetHashCode());

            return domainObj;
        }

        /**
         * This event is fired at the very end of the call to Build(). It is useful for maintaining
         * or creating bi directional associations in the domain model that would otherwise
         * cause endless recursive calls to various builders' Build() methods.
         */
        public delegate void PostBuildHandler(object sender, PostBuildEventArgs<TDOMAIN> e);
        public event PostBuildHandler PostBuildEvent;
        public virtual void OnPostBuild(object sender, PostBuildEventArgs<TDOMAIN> eventArgs)
        {
            // Does nothing by default
        }

        protected void FireOnPostBuild(TDOMAIN domainObj)
        {
            if (PostBuildEvent == null) return;

            var args = new PostBuildEventArgs<TDOMAIN>(domainObj);
            PostBuildEvent(this, args);
        }

        // TRETURNS is the return type of property
        // TDOMAIN is the type of the class with property as a member
        // TDOMAINBASE is the type that all types of TDOMAIN inherit from (base domain class)
        // TBUILDER is the type of the builder that builds TDOMAIN

        /**
         * Set a property equal to an actual value. Could be an object or a collection depending
         * on the property's type.
         */
        public TTHIS With<TRETURNS>(Expression<Func<TDOMAIN, TRETURNS>> property, TRETURNS value)
        {
            var propertyInfo = _helper.GetPropertyInfo(property);
            SetPropertyValue(propertyInfo, value);
            return (TTHIS)this;
        }

        /**
         * Set a property equal to the value generated by another builder. Other builder's
         * Build() return type must match type of property.
         */
        public TTHIS With<TRETURNS, TBUILDER>(
            Expression<Func<TDOMAIN, TRETURNS>> property,
            ITestDataBuilder<TRETURNS, TBUILDER> builder)
            where TBUILDER : ITestDataBuilder<TRETURNS, TBUILDER>, new()
        {
            var propertyInfo = _helper.GetPropertyInfo(property);
            SetPropertyValue(propertyInfo, builder);
            return (TTHIS)this;
        }

        /**
         * Creates a collection from a params array of values and assigns it to a property. 
         * The type of the values must match the generic parameter of the collection type 
         * specified on the property.
         */
        public TTHIS Withs<TRETURNS, TSUBDOMAIN>(
            Expression<Func<TDOMAIN, TRETURNS>> property,
            params TSUBDOMAIN[] values)
            where TRETURNS : IList<TSUBDOMAIN>
        {
            var list = new List<TSUBDOMAIN>();

            foreach (var value in values)
                list.Add(value);

            var propertyInfo = _helper.GetPropertyInfo(property);
            SetPropertyValue(propertyInfo, list);

            return (TTHIS)this;
        }

        private object GetValueFromBuilder(object testDataBuilder)
        {
            // NOTE: value should have been vetted by IsITestDataBuilder() first

            var buildMethod = testDataBuilder
                .GetType()
                .GetMethod("Build",
                           BindingFlags.Instance | BindingFlags.Public);

            var value = buildMethod.Invoke(testDataBuilder, null);

            return value;
        }

        private bool IsITestDataBuilder(object mayBeBuilder)
        {
            if (mayBeBuilder == null)
                return false;

            if (mayBeBuilder.GetType().IsValueType)
                return false;

            var iTestDataBuilderTypeDefinition = typeof(ITestDataBuilder<,>);

            var iTestDataBuilderType = mayBeBuilder
                .GetType()
                .GetInterface(iTestDataBuilderTypeDefinition.Name);

            return (iTestDataBuilderType != null);
        }

        public virtual TTHIS But 
        {
            get
            {
                var clone = new TTHIS();

                foreach (var key in _propertyValues.Keys)
                    clone.SetPropertyValue(key, _propertyValues[key]);

                return clone;
            }
        }

        protected void SetPropertyValue<T>(PropertyInfo key, T value)
        {
            if (_propertyValues.ContainsKey(key))
                _propertyValues[key] = value;
            else
                _propertyValues.Add(key, value);
        }
    }
}